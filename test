#include "shell.h"


#define MAX_INPUT_SIZE 100

void execmd(char *argv[]) {
    pid_t pid = fork();

    if (pid == -1) {
        perror("Error: Fork failed");
        return;
    } else if (pid == 0) {
        /* Child process*/
        char *comd = NULL;
        char *actual_comd = NULL;

        if (argv) {
            comd = argv[0];
            actual_comd = get_location(comd);

            if (execve(actual_comd, argv, NULL) == -1) {
                perror("Error: recheck your command");
                exit(1);  /* Exit child process on error */
            }
        }
    } else {
        /* Parent process*/
        wait(NULL);  /*Wait for the child process to finish*/
    }
}


void exit_shell() {
    write(STDOUT_FILENO, "Exiting ...\n", 12);
    exit(0);
}

char *get_location(char *comd) {
    char *get_path = getenv("PATH");

    if (get_path) {
        char *get_path_copy = strdup(get_path);
        char *get_path_token = strtok(get_path_copy, ":");
        struct stat buffer;

        while (get_path_token != NULL) {
            int command_length = strlen(comd);
            int directory_length = strlen(get_path_token);

            char *get_file_path = malloc(command_length + directory_length + 2);
            strcpy(get_file_path, get_path_token);
            strcat(get_file_path, "/");
            strcat(get_file_path, comd);

            if (stat(get_file_path, &buffer) == 0) {
                free(get_path_copy);
                return get_file_path;
            }

            free(get_file_path);
            get_path_token = strtok(NULL, ":");
        }

        free(get_path_copy);

        if (stat(comd, &buffer) == 0) {
            return strdup(comd);
        }
    }

    return NULL;
}

int main() {
    char *prompt = "(ourshell) $ ";
    char *lineptr = NULL;
    char *lineptr_copy = NULL;
    size_t n = 0;
    ssize_t written;
    const char *delim = " \n";
    int ntokens = 0;
    char *tokens;
    int i;
    int j;
    char **argv;

    while (1) {
        write(STDOUT_FILENO, prompt, strlen(prompt));

        written = getline(&lineptr, &n, stdin);

        if (written > 0 && lineptr[written - 1] == '\n') {
            lineptr[written - 1] = '\0';
        }

        if (strcmp(lineptr, "exit") == 0) {
            exit_shell();
        }

        if (written == EOF) {
            write(STDOUT_FILENO, "Exiting ...\n", 12);
            return -1;
        }

        lineptr_copy = malloc(sizeof(char) * written);

        if (lineptr_copy == NULL) {
            write(STDERR_FILENO, "Error: memory allocation failed...\n", 34);
            return -1;
        }

        strcpy(lineptr_copy, lineptr);

        tokens = strtok(lineptr, delim);

        while (tokens != NULL) {
            ntokens++;
            tokens = strtok(NULL, delim);
        }

        ntokens++;

        argv = malloc(sizeof(char *) * ntokens);

        tokens = strtok(lineptr_copy, delim);

        for (i = 0; tokens != NULL; i++) {
            argv[i] = malloc(sizeof(char) * strlen(tokens));
            strcpy(argv[i], tokens);
            tokens = strtok(NULL, delim);
        }

        argv[i] = NULL;

        execmd(argv);

        for (j = 0; j < i; j++) {
            free(argv[j]);
        }

        free(argv);
        free(lineptr_copy);
    }

    free(lineptr);
    return 0;
}
